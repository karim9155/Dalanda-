%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Detailed PFE Report Template (50+ Pages)
%
% Based on ESCOMP Style
% Adapted for "Dalanda" Project by Gemini
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt, a4paper, oneside]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage[english]{babel} % For English typography rules
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\usepackage{geometry}
\geometry{a4paper, top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

\usepackage{tocbibind} % Add ToC, LoF, LoT, Bibliography to the Table of Contents
\usepackage{listings} % For code snippets
\usepackage{xcolor}   % For custom colors in code
\usepackage{booktabs} % For professional quality tables
\usepackage{float}    % To improve figure placement with [H]

% Define custom colors for code listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configure listings style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Spacing between paragraphs
\setlength{\parskip}{1.5ex}

%----------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------



% path to your images folder
\graphicspath{{images/}}

\begin{figure}[H]
  \centering
\includegraphics[width=\paperwidth,height=\paperheight,trim=1cm 2cm 0cm 1cm,clip]{Page Garde Rapport Stage Ang_page-0001.jpg}

\end{figure}
\newpage

\begin{figure}[H]
  \centering
  \includegraphics[width=\paperwidth,height=\paperheight]{Page Garde Rapport Stage Ang_page-0002.jpg}
\end{figure}
\newpage

\begin{figure}[H]
  \centering
  \includegraphics[width=\paperwidth,height=\paperheight]{Page Garde Rapport Stage Ang_page-0003.jpg}
\end{figure}
\newpage


%----------------------------------------------------------------------------------------
%	FRONT MATTER
%----------------------------------------------------------------------------------------

\frontmatter % Roman numerals for page numbers

\chapter*{Acknowledgements}
I want to express my deep gratitude to... % Your acknowledgements text
\newpage

\tableofcontents
\newpage

\listoffigures
\newpage

\listoftables
\newpage

\chapter*{Acronymes}
\begin{tabular}{l l}
    \textbf{API} & Application Programming Interface \\
    \textbf{CRUD} & Create, Read, Update, Delete \\
    \textbf{JWT} & JSON Web Token \\
    \textbf{JPA} & Jakarta Persistence API \\
    \textbf{NLP} & Natural Language Processing \\
    \textbf{PFE} & Projet de Fin d'Ã‰tudes \\
    \textbf{SPA} & Single Page Application \\
    \textbf{UML} & Unified Modeling Language \\
    % Add other acronyms you use
\end{tabular}
\newpage

%----------------------------------------------------------------------------------------
%	MAIN CONTENT
%----------------------------------------------------------------------------------------

\mainmatter % Arabic numerals for page numbers

\chapter{General Introduction}
% Aim for 2-3 pages for this chapter.
\section{Context}
Invoice management is a cornerstone of any company's long-term viability, especially for the small and medium-sized enterprises (SMEs) that form the backbone of the economy. Accurate and timely invoicing is not only a legal obligation but is also crucial for maintaining healthy cash flow, ensuring regulatory compliance, and preserving good customer relationships.

However, many SMEs and self-employed individuals still rely on manual processes to manage this critical part of their operations. Using spreadsheets like Excel or Word documents to create, track, and archive invoices is a common practice. While functional on a small scale, these methods quickly reveal their limitations: they are time-consuming, prone to human error (miscalculations, forgotten VAT, incorrect invoice numbers), and offer limited traceability. Tracking payments becomes a tedious task, increasing the risk of delays and defaults that can weaken a company's financial stability.

In parallel, the professional world is undergoing a rapid digital transformation. Software as a Service (SaaS) solutions have emerged, offering invoicing tools of varying complexity. However, these solutions can be costly, oversized for the actual needs of small organizations, or lacking in flexibility. Moreover, adopting a new tool often presents a barrier, requiring a learning curve and the migration of existing data.

In this landscape, a key trend is emerging: the integration of work tools into daily communication flows. Instant messaging applications like Telegram are no longer just for discussion but are becoming genuine productivity platforms. The rise of conversational assistants, powered by advancements in artificial intelligence (AI) and natural language processing (NLP), is paving the way for more intuitive and accessible interactions. It is within this context that the Dalanda project is positioned: addressing the need for a modern, simple, and efficient invoicing solution that integrates with current mobile usage habits.

\section{Problem Statement}
The central problem of this project stems directly from the context described. SMEs and independent workers face a dilemma: either they continue with manual invoicing methods, thereby accepting inefficiency, the risk of errors, and the associated mental load; or they invest in off-the-shelf invoicing software that is often unsuitable, either due to its prohibitive cost or its unnecessary complexity.

The core of the problem can be broken down into several friction points:

\begin{itemize}
    \item \textbf{Accessibility and Cost:} Comprehensive software solutions represent a significant investment, often in the form of monthly subscriptions, which can be a barrier for a startup or a freelancer.
    \item \textbf{Complexity and Learning Curve:} Many invoicing software packages are designed for larger companies and include a plethora of features (inventory management, advanced accounting, etc.) that are unnecessary for a small business. This complexity leads to a cluttered interface and a steep learning curve that discourages adoption.
    \item \textbf{Wasted Time and Manual Errors:} Manually creating invoices in spreadsheets or word processors is repetitive and prone to data entry mistakes, VAT calculation errors, or numbering issues, which can have legal and financial consequences. Tracking due dates and payments is also a source of stress and wasted time.
    \item \textbf{Lack of Mobility and Immediacy:} Processes based on office files are not well-suited for mobile use. Creating or viewing an invoice from a smartphone is often cumbersome, yet responsiveness is a key part of the client relationship.
    \item \textbf{Context Switching:} Invoice management typically occurs outside of the communication channels where business is discussed. A client might request a quote on Telegram, the conversation continues over email, and the invoice is ultimately generated in another software. This fragmentation of processes undermines efficiency.
\end{itemize}

The problem statement is therefore as follows: How can we provide small businesses with an invoicing tool that is powerful, easy to access, affordable, and seamlessly integrates into their daily digital communication habits to reduce administrative friction and accelerate the billing cycle? This project aims to answer this question by proposing a solution that combines the robustness of a web application with the simplicity of a conversational interface.
\section{Project Objectives}
% List the objectives clearly.
The main objective of this project, named \textbf{Dalanda}, is to design and develop a complete invoice management solution. The sub-objectives are as follows:
\begin{itemize}
    \item Implement a robust and secure RESTful API with Spring Boot.
    \item Develop an intuitive and responsive single-page web interface (SPA) with Angular.
    \item Implement a conversational assistant on Telegram capable of understanding and executing commands in natural language.
    \item Orchestrate the assistant's logic using the n8n automation platform.
    \item Ensure the deployment of the solution using Docker.
\end{itemize}
\section{Report Structure}
% Briefly describe the content of each chapter.
This report is structured into five chapters. The first chapter presents the general context of the project... The second chapter offers a detailed state of the art... The third chapter is devoted to technical design... The fourth chapter describes the concrete implementation... Finally, the fifth chapter is dedicated to the testing and validation strategy...

\chapter{Context, State of the Art and Needs Analysis}
% Aim for 8-12 pages. This is a key academic chapter.
\section{Introduction}
This chapter lays the foundational context for the Dalanda project. It begins by presenting the host organization, Switzerland Innovation & Co., to situate the project within a real-world business environment. Following this, a detailed state-of-the-art analysis is conducted, examining existing invoicing solutions to identify market gaps and technological trends. This analysis justifies the key technology choices made for the project. Finally, the chapter concludes with a formal specification of the functional and non-functional requirements, which define the precise scope and objectives of the solution to be built.
\section{Presentation of the Host Organization}
\subsection{History and Activities}
The internship was conducted at \textbf{Switzerland Innovation \& Co.}, a company specializing in IT, artificial intelligence, marketing, and customer service outsourcing for businesses in French-speaking Switzerland. While the company's detailed history is not public, it operates internationally with offices in Geneva, Tunis, and Marrakech, leveraging a diverse talent pool skilled in new technologies and innovative marketing.

The company's services are structured around four main areas:
\begin{itemize}
    \item \textbf{Marketing Services:} Development of marketing strategies, branding, community management, and digital advertising campaigns.
    \item \textbf{Web Marketing \& IT:} Creation of modern websites, integration of custom IT solutions, and CRM development.
    \item \textbf{Artificial Intelligence:} Consulting on AI integration, design and deployment of AI applications, and team training.
    \item \textbf{Customer Service Outsourcing:} Provision of call center teams and complete customer service operations.
\end{itemize}

Switzerland Innovation \& Co. positions itself as a trusted partner for outsourcing, emphasizing its deep understanding of the Swiss Romande market, responsiveness, and a commitment to innovation, particularly through the integration of cutting-edge technologies like AI.

\subsection{Project Positioning}
The \textbf{Dalanda} project aligns perfectly with the company's core mission to "foster innovation by integrating cutting-edge technologies" and to "design and deploy high-impact AI solutions." This project serves a dual purpose:

\begin{enumerate}
    \item \textbf{Internal Need:} The project addresses an internal need for a modern, efficient, and cost-effective invoice management tool. By developing this solution in-house, the company can streamline its own billing processes, reducing administrative overhead and improving cash flow management.
    \item \textbf{Proof of Concept:} The Dalanda project also acts as a powerful proof of concept for clients. It demonstrates the company's ability to develop and integrate sophisticated, AI-driven applications that solve real-world business problems. The conversational assistant, in particular, showcases the company's expertise in AI and its potential to create intuitive and user-friendly solutions.
\end{enumerate}

Ultimately, the project supports the company's overarching goal of helping businesses optimize their processes and reduce costs by outsourcing non-core tasks. It serves as a tangible example of the innovative solutions that Switzerland Innovation \& Co. can offer its clients.
\section{State of the Art}
\subsection{Comparative Analysis of Invoicing Systems}
% This is a major section. Create a table comparing 3-4 existing solutions (e.g., Zoho Invoice, FreshBooks, Wave).
% Compare them on criteria like: Features, Pricing, API availability, User Experience, Mobile Access, Automation Capabilities.
\begin{table}[H]
    \centering
    \caption{Comparative table of existing invoicing solutions.}
    \label{tab:comparison}
    \begin{tabular}{l p{3cm} p{3cm} p{3cm}}
        \toprule
        \textbf{Criterion} & \textbf{Zoho Invoice} & \textbf{FreshBooks} & \textbf{Wave} \\
        \midrule
        Price model & Freemium & By subscription & Free (with transaction fees) \\
        API Access & Yes, complete & Yes & Limited \\
        Automation & Advanced & Medium & Basic \\
        Mobile Interface & Dedicated app & Dedicated app & Web responsive \\
        \bottomrule
    \end{tabular}
\end{table}
The analysis of existing solutions reveals a clear market segmentation. On one hand, solutions like Zoho Invoice and FreshBooks offer comprehensive feature sets but come with subscription costs that can be a barrier for freelancers or very small businesses. On the other hand, free solutions like Wave are attractive but often have limitations, such as a less developed API or basic automation capabilities.

The Dalanda project positions itself in a strategic gap: it offers the richness of a complete, modern web application combined with an innovative, mobile-first interaction model via a conversational assistant, without the direct cost of a subscription. This hybrid approach, which combines a traditional web interface for complex tasks with the immediacy of a chatbot for quick actions, is a key differentiator. It directly addresses the need for a solution that is both powerful and accessible, and that integrates naturally into the user's daily communication workflow.
\subsection{Study of Key Technologies}
\subsubsection{Backend Architecture: The choice of Spring Boot}
Spring Boot was chosen as the backend framework for its robustness, scalability, and extensive ecosystem, making it ideal for enterprise-level applications. Its key advantages for this project include:
\begin{itemize}
    \item \textbf{Rapid Development:} Spring Boot's convention-over-configuration approach and embedded servers (like Tomcat) significantly accelerate development and simplify deployment.
    \item \textbf{Rich Ecosystem:} The project leverages several components of the Spring ecosystem:
    \begin{itemize}
        \item \textbf{Spring Data JPA:} Simplifies data access by providing a repository abstraction layer, reducing boilerplate code for database operations.
        \item \textbf{Spring Security:} Provides a comprehensive and highly customizable security framework, which was essential for implementing the JWT-based authentication and protecting the REST API.
    \end{itemize}
    \item \textbf{Scalability and Performance:} Spring Boot is designed for building high-performance, scalable applications, which is crucial for a service that could potentially handle a large number of users and transactions.
\end{itemize}

\subsubsection{Frontend Architecture: The choice of Angular}
Angular was selected for the frontend to create a modern, responsive, and maintainable single-page application (SPA). Its main strengths in the context of this project are:
\begin{itemize}
    \item \textbf{Component-Based Architecture:} Promotes a modular and reusable code structure, which simplifies development and maintenance.
    \item \textbf{TypeScript:} The use of TypeScript brings type safety to the frontend, which helps to catch errors early and improves code quality.
    \item \textbf{Powerful CLI:} The Angular CLI automates many development tasks, such as creating components, services, and modules, which boosts productivity.
    \item \textbf{Angular Material:} The integration of Angular Material provides a rich library of high-quality, pre-built UI components, ensuring a consistent and professional user interface.
\end{itemize}

\subsubsection{Automation and Integration: The power of n8n}
n8n was chosen as the workflow automation tool to orchestrate the logic of the Telegram assistant. Its key benefits over alternatives like Zapier or writing a custom bot from scratch are:
\begin{itemize}
    \item \textbf{Open-Source and Self-Hostable:} This provides complete control over the tool and its data, which is a significant advantage for security and customization.
    \item \textbf{Visual Interface:} n8n's node-based visual editor makes it easy to design, debug, and modify complex workflows without writing extensive code.
    \item \textbf{Flexibility:} It offers a wide range of integrations and the ability to write custom JavaScript code within nodes, providing the flexibility needed to connect Telegram, the AI service, and the backend API.
\end{itemize}

\subsubsection{Conversational Interfaces and AI}
The integration of a conversational assistant represents a shift towards a more intuitive and accessible user experience. This paradigm, known as Conversational UI, allows users to interact with software using natural language, which lowers the barrier to entry and makes the application more accessible, especially on mobile devices.

The core of this interface is the use of a Large Language Model (LLM) for Natural Language Processing (NLP). The LLM's ability to understand unstructured text and extract structured data (in this case, a JSON object representing the user's intent and entities) is what makes the conversational assistant possible. This approach is more powerful than traditional, rule-based chatbots, as it can handle a wider range of user inputs and is more resilient to variations in language. The project leverages this capability to parse commands like "create an invoice for client X" into a structured API call, seamlessly bridging the gap between human language and machine execution.
\section{Analysis and Specification of Needs}
% This section formally defines the requirements derived from your state-of-the-art analysis.
\subsection{Functional Requirements (User Stories)}
\begin{table}[H]
    \centering
    \caption{Examples of functional requirements in the form of User Stories.}
    \label{tab:user_stories}
    \begin{tabular}{l p{10cm}}
        \toprule
        \textbf{ID} & \textbf{Description} \\
        \midrule
        UF-01 & As a user, I want to be able to register and log in to secure access to my data. \\
        UF-02 & As a user, I want to create, view, modify and delete customers and companies. \\
        UF-03 & As a user, I want to create a detailed invoice (multiple items, taxes, dates). \\
        UF-04 & As a user, I want to be able to tell my Telegram bot "create an invoice" to initiate the creation process. \\
        UF-05 & As a user, I want to be able to upload a logo and a stamp for my company to personalize my invoices. \\
        UF-06 & As a user, I want to be able to download a PDF version of any invoice. \\
        UF-07 & As a user, I want to see a list of all my invoices with their status (e.g., paid, pending). \\
        \bottomrule
    \end{tabular}
\end{table}
\subsection{Non-Functional Requirements}
% Detail these requirements.
\begin{itemize}
    \item \textbf{Security:} Use of HTTPS for all communications. Passwords must be hashed using BCrypt. The application must be protected against common web vulnerabilities, including XSS and CSRF attacks. API endpoints must be secured, and access should be restricted based on user roles.
    \item \textbf{Performance:} The REST API should have an average response time of less than 200ms for standard CRUD operations under normal load. The web interface should load in under 3 seconds.
    \item \textbf{Reliability:} The application should have a target availability of 99.9\%. All critical functionalities, such as invoice creation and PDF generation, must be thoroughly tested to prevent failures.
    \item \textbf{Scalability:} The architecture should be able to handle a growing number of users and data without a significant degradation in performance. The use of a stateless backend and a scalable database is key to achieving this.
    \item \textbf{Maintainability:} The code must be modular, well-documented, and follow the best practices of the respective frameworks (Spring Boot and Angular). This will facilitate future updates and the addition of new features.
    \item \textbf{Usability:} The web interface should be intuitive and easy to use, requiring minimal training for a new user. The conversational assistant should be able to understand common variations of commands.
\end{itemize}

\chapter{Solution Design and Architecture}
% Aim for 10-15 pages. This chapter shows your engineering thought process.
\section{Introduction}
This chapter presents the software architecture and detailed design models of the Dalanda solution.
\section{Global Architecture}
% Use this section to present your high-level diagrams and explain how everything connects.
\subsection{Component Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/component_diagram.png}
    \caption{Application component diagram.}
    \label{fig:component_diagram}
\end{figure}
\subsection{Deployment Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/deployment_diagram.png}
    \caption{Solution deployment diagram on Docker.}
    \label{fig:deployment_diagram}
\end{figure}
\section{Detailed Backend Design}
\subsection{Conceptual Data Model (CDM)}
% Include your class diagram or an Entity-Relationship Diagram.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{path/to/your/class_diagram.png}
    \caption{Class diagram of JPA entities.}
    \label{fig:class_diagram_detail}
\end{figure}
\subsection{REST API Design}
The API is structured around several key resources, each with its own set of endpoints.

\subsubsection{Authentication API (/api/auth)}
\begin{itemize}
    \item \textbf{POST /api/auth/register}: Creates a new user account.
    \item \textbf{POST /api/auth/login}: Authenticates a user and returns a JWT token.
\end{itemize}

\subsubsection{User API (/api/auth/users)}
\begin{itemize}
    \item \textbf{GET /api/auth/users/me}: Retrieves the ID of the currently authenticated user.
\end{itemize}

\subsubsection{Client Management API (/api/clients)}
\begin{itemize}
    \item \textbf{GET /api/clients}: Retrieves a list of all clients.
    \item \textbf{GET /api/clients/\{id\}}: Retrieves a single client by their ID.
    \item \textbf{POST /api/clients}: Creates a new client.
    \item \textbf{PUT /api/clients/\{id\}}: Updates an existing client.
    \item \textbf{DELETE /api/clients/\{id\}}: Deletes a client.
\end{itemize}

\subsubsection{Company Management API (/api/companies)}
\begin{itemize}
    \item \textbf{GET /api/companies}: Retrieves a list of all companies.
    \item \textbf{GET /api/companies/\{id\}}: Retrieves a single company by its ID.
    \item \textbf{POST /api/companies}: Creates a new company.
    \item \textbf{PUT /api/companies/\{id\}}: Updates an existing company.
    \item \textbf{DELETE /api/companies/\{id\}}: Deletes a company.
    \item \textbf{POST /api/companies/\{id\}/logo}: Uploads a logo for a specific company.
    \item \textbf{POST /api/companies/\{id\}/stamp}: Uploads a stamp/signature for a specific company.
\end{itemize}

\subsubsection{Invoice Management API (/api/invoices)}
\begin{itemize}
    \item \textbf{GET /api/invoices}: Retrieves a list of all invoices.
    \item \textbf{GET /api/invoices/user/\{userId\}}: Retrieves all invoices for a specific user.
    \item \textbf{GET /api/invoices/\{id\}}: Retrieves a single invoice by its ID.
    \item \textbf{POST /api/invoices}: Creates a new invoice.
    \item \textbf{PUT /api/invoices/\{id\}}: Updates an existing invoice.
    \item \textbf{DELETE /api/invoices/\{id\}}: Deletes an invoice.
    \item \textbf{GET /api/invoices/\{id\}/pdf}: Generates and downloads a PDF version of a specific invoice.
\end{itemize}
\subsection{Sequence Diagrams of Main Use Cases}
% Include sequence diagrams for key scenarios.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{path/to/your/seq_create_invoice_api.png}
    \caption{Sequence diagram: Creation of an invoice via the REST API.}
    \label{fig:seq_api}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{path/to/your/seq_create_invoice_telegram.png}
    \caption{Sequence diagram: Creation of an invoice via Telegram and n8n.}
    \label{fig:seq_telegram}
\end{figure}

\section{n8n Workflow Design}
% Use the image you provided.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{path/to/your/n8n_workflow_full.png}
    \caption{Detailed view of the n8n automation workflow.}
    \label{fig:n8n_workflow_detail}
\end{figure}
\subsection{AI Node Logic (Prompt Engineering)}
% This is a very important part. Explain the prompt you gave to the AI.
The system prompt of the OpenAI node is crucial. It instructs the model to only respond in JSON and to structure its output according to the detected intent...
\begin{lstlisting}[language=json, caption={Example of expected JSON output from the AI}]
{
  "action": "client",
  "companyName": "ABC Corp",
  "otherInfo": "Some other info"
}
\end{lstlisting}

\chapter{Sprint 1: Backend Foundation and Core API}
\section{Introduction}
This chapter details the work carried out during the first sprint, which focused on establishing the technical foundation of the backend application. The primary goals were to set up the Spring Boot project, implement a robust security layer, and develop the core APIs for user and client management.

\section{Sprint Backlog}
The backlog for this sprint included the following user stories:
\begin{itemize}
    \item As a user, I want to register for an account so I can access the service.
    \item As a user, I want to log in securely to the application to protect my data.
    \item As a developer, I need a project structure with proper dependency management (Maven).
    \item As an authenticated user, I want to create, read, update, and delete clients.
\end{itemize}

\section{Design and Implementation}
\subsection{Project Setup}
The project was initialized using Spring Initializr with Java 17, Maven, and key dependencies like Spring Web, Spring Data JPA, and Spring Security.

\subsection{Security Implementation}
A security layer using JWT (JSON Web Tokens) was implemented. This involved creating a `JwtTokenProvider` to generate and validate tokens, and configuring Spring Security to protect endpoints, requiring authentication for all API calls except for registration and login.

\subsection{API Development}
The following core endpoints were developed and tested:
\begin{itemize}
    \item `POST /api/auth/register`
    \item `POST /api/auth/login`
    \item `GET, POST, PUT, DELETE /api/clients`
\end{itemize}

\section{Sprint Review}
At the end of the sprint, the backend was functional, with a secure authentication system and a complete CRUD API for client management. The main challenge was correctly configuring the JWT security filter chain.

\section{Burndown Chart}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/sprint1_burndown.png}
    \caption{Burndown chart for Sprint 1.}
    \label{fig:sprint1_burndown}
\end{figure}

\chapter{Sprint 2: Frontend Implementation and Entity Management}
\section{Introduction}
The second sprint was dedicated to building the frontend application using Angular. The main objectives were to create the user interface for authentication, as well as for managing clients and companies, and to connect these components to the backend API developed in Sprint 1.

\section{Sprint Backlog}
\begin{itemize}
    \item As a user, I want a web page to register and log in.
    \item As a logged-in user, I want to see a dashboard where I can manage my data.
    \item As a user, I want a user-friendly interface to add, view, edit, and delete my clients.
    \item As a user, I want to be able to manage my company's details, including uploading a logo and a stamp.
\end{itemize}

\section{Design and Implementation}
\subsection{Angular Project Setup}
An Angular project was created using the Angular CLI. Angular Material was chosen for UI components to ensure a consistent and professional look.

\subsection{Authentication UI}
Login and registration forms were created. An `AuthService` was implemented to handle communication with the backend, and an HTTP interceptor was used to attach the JWT token to all subsequent requests.

\subsection{Client and Company Management UI}
CRUD interfaces for clients and companies were developed. This included creating forms for data entry and tables to display the existing data. Services were created to interact with the `/api/clients` and `/api/companies` endpoints.

\section{Sprint Review}
By the end of this sprint, a functional frontend was in place. Users could register, log in, and manage their clients and company information. The main challenge was mastering reactive forms in Angular for complex data structures.

\section{Burndown Chart}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/sprint2_burndown.png}
    \caption{Burndown chart for Sprint 2.}
    \label{fig:sprint2_burndown}
\end{figure}

\chapter{Sprint 3: Invoice Management and PDF Generation}
\section{Introduction}
This sprint focused on the core functionality of the application: invoice management. The goals were to implement the backend logic and frontend interface for creating and managing invoices, as well as the ability to generate PDF versions of these invoices.

\section{Sprint Backlog}
\begin{itemize}
    \item As a user, I want to create a new invoice with multiple line items, taxes, and due dates.
    \item As a user, I want to view a list of all my invoices and see their status (e.g., paid, pending).
    \item As a user, I want to be able to edit and delete existing invoices.
    \item As a user, I want to download a PDF version of any invoice for my records or to send to a client.
\end{itemize}

\section{Design and Implementation}
\subsection{Backend Invoice API}
The Spring Boot application was extended with a new set of endpoints under `/api/invoices` for full CRUD functionality. A service layer was created to handle the business logic, such as calculating totals and managing invoice statuses.

\subsection{PDF Generation}
The iTextPDF library was integrated into the backend. A `PdfGeneratorService` was created to take invoice data and generate a professional-looking PDF document, including the company logo and other details.

\subsection{Frontend Invoice UI}
The Angular application was updated with a new module for invoice management. This included a complex reactive form for creating and editing invoices, especially for handling a dynamic list of invoice items using `FormArray`.

\section{Sprint Review}
The core feature of the application was completed in this sprint. Users could now manage the entire lifecycle of an invoice. The PDF generation proved challenging, especially with regard to layout and styling.

\section{Burndown Chart}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/sprint3_burndown.png}
    \caption{Burndown chart for Sprint 3.}
    \label{fig:sprint3_burndown}
\end{figure}

\chapter{Sprint 4: Conversational Assistant and n8n Integration}
\section{Introduction}
The final sprint was focused on innovation by adding a conversational assistant via Telegram. The goal was to allow users to perform simple actions, like creating an invoice, using natural language commands from their mobile devices.

\section{Sprint Backlog}
\begin{itemize}
    \item As a user, I want to connect my account to a Telegram bot.
    \item As a user, I want to be able to say "create an invoice for client X for 500 dollars" and have a draft invoice created.
    \item As a developer, I need to set up a workflow automation tool (n8n) to orchestrate the interaction between Telegram and my backend.
    \item As a developer, I need to integrate an AI service to parse natural language into structured data.
\end{itemize}

\section{Design and Implementation}
\subsection{Telegram Bot Setup}
A new bot was created on Telegram using the BotFather, and its API token was obtained.

\subsection{n8n Workflow}
A new workflow was designed in n8n. The workflow is triggered by an incoming message on Telegram. It then sends the message to an OpenAI node for natural language processing. The AI is prompted to extract the intent and entities (e.g., action, client name, amount) and return a JSON object.

\subsection{Backend Integration}
The n8n workflow then makes a call to the backend API (`POST /api/invoices`) with the structured data to create the invoice. The workflow handles user session management to associate the Telegram user with their account in the application.

\section{Sprint Review}
This sprint successfully delivered a powerful and innovative feature. The conversational assistant worked as expected, though "prompt engineering" for the AI node required several iterations to become reliable. The integration between the different services (Telegram, n8n, OpenAI, and the Spring backend) was the most complex part of this sprint.

\section{Burndown Chart}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{path/to/your/sprint4_burndown.png}
    \caption{Burndown chart for Sprint 4.}
    \label{fig:sprint4_burndown}
\end{figure}

\chapter{Tests and Validation}
\section{Introduction}
To ensure the quality, reliability, and robustness of the Dalanda application, a comprehensive, multi-level testing strategy was implemented. This strategy covers everything from individual code units to the complete, integrated system. The following sections describe the different types of tests that were conducted throughout the project's lifecycle.

\section{Unit Tests}
Unit tests were written to verify the functionality of individual components in isolation.

\subsection{Backend Tests}
The backend, built with Spring Boot, was tested using \textbf{JUnit 5} and \textbf{Mockito}. Services were tested by mocking their dependencies (like repositories) to ensure that business logic was correctly implemented. For example, the `InvoiceService` was tested to confirm that invoice totals were calculated correctly and that invoice statuses were managed properly. Controllers were tested using `MockMvc` to verify that they handled HTTP requests correctly, returned the expected status codes, and secured the endpoints properly.

\begin{lstlisting}[language=Java, caption={Example of a Unit Test for InvoiceService}]
@ExtendWith(MockitoExtension.class)
class InvoiceServiceTest {

    @Mock
    private InvoiceRepository invoiceRepository;

    @InjectMocks
    private InvoiceServiceImpl invoiceService;

    @Test
    void testCreateInvoice_calculatesTotalCorrectly() {
        // Given
        Invoice newInvoice = new Invoice();
        // ... set up invoice items and taxes

        // When
        Invoice savedInvoice = invoiceService.createInvoice(newInvoice);

        // Then
        // ... assert that the total is calculated as expected
        assertThat(savedInvoice.getTotal()).isEqualTo(expectedTotal);
    }
}
\end{lstlisting}

\subsection{Frontend Tests}
The Angular frontend was tested using \textbf{Karma} and \textbf{Jasmine}. Unit tests were created for individual components to ensure they rendered correctly and that their internal logic (e.g., form validation, event handling) worked as expected. Services, like the `AuthService`, were also tested by mocking the `HttpClient` to simulate API calls and verify that the service handled responses and errors correctly.

\section{Integration Tests}
Integration tests were performed to verify the interaction between different parts of the system.

\subsection{REST API Test}
The REST API was tested using \textbf{Postman}. A collection of requests was created to test all endpoints, verifying authentication, data validation, and correct responses for the entire CRUD lifecycle of each entity (clients, companies, invoices). These tests ensured that the frontend and backend could communicate correctly.

\subsection{n8n Workflow Test}
The n8n workflow, which represents a critical integration point, was tested end-to-end. This involved sending specific messages from a Telegram client and verifying the entire chain of events:
\begin{enumerate}
    \item The message is received by the n8n workflow.
    \item The AI node correctly parses the intent and entities.
    \item The workflow successfully calls the backend API.
    \item A new invoice is created in the database with the correct information.
\end{enumerate}
This manual but crucial testing ensured that the entire conversational assistant feature was working as intended.

\section{Functional Validation}
Functional validation was performed to ensure that the application met the requirements defined in the user stories. The following table links the main functional requirements to their test scenarios and results.

\begin{table}[H]
    \centering
    \caption{Validation of Key Use Cases}
    \label{tab:validation}
    \begin{tabular}{l p{7cm} l}
        \toprule
        \textbf{ID} & \textbf{Test Scenario} & \textbf{Result} \\
        \midrule
        UF-01 & A new user registers and logs in successfully. An existing user can log in. Invalid credentials are rejected. & Passed \\
        UF-02 & A logged-in user can create, view, update, and delete clients and companies. & Passed \\
        UF-03 & A user creates a detailed invoice with multiple items and taxes. The total is calculated correctly. & Passed \\
        UF-04 & A user sends "create an invoice for ClientX for 500" on Telegram. A draft invoice is created for ClientX with a total of 500. & Passed \\
        \bottomrule
    \end{tabular}
\end{table}

\chapter{General Conclusion}
\section{Project Summary}
This project, named \textbf{Dalanda}, successfully achieved its primary objective: to design and develop a modern, accessible, and efficient invoice management solution tailored for small and medium-sized enterprises (SMEs) and freelancers. The project delivered a complete system composed of a secure Spring Boot backend, an intuitive Angular web interface, and an innovative conversational assistant on Telegram, all orchestrated through an n8n workflow.

The solution addresses the key problems identified in the project's context, offering a powerful alternative to manual, error-prone invoicing methods and overly complex or expensive off-the-shelf software. By integrating with a popular messaging platform like Telegram, the project pioneers a more fluid and immediate user experience, reducing administrative friction and context switching for users.

\section{Project Contributions}
\subsection{Technical and Professional Contributions}
This project provided an opportunity to work with a wide range of modern technologies and architectural patterns. Key technical skills gained and applied include:
\begin{itemize}
    \item \textbf{Backend Development:} Deepened expertise in the Spring ecosystem, including Spring Boot, Spring Data JPA for database interactions, and Spring Security for implementing robust, token-based (JWT) authentication.
    \item \textbf{Frontend Development:} Gained proficiency in Angular for building a reactive, single-page application (SPA). This included mastering component-based architecture, reactive forms for complex data entry, and service-based communication with a REST API.
    \item \textbf{DevOps and Deployment:} Acquired hands-on experience with Docker and Docker Compose for containerizing the application and its database, ensuring a consistent and reproducible deployment environment.
    \item \textbf{Integration and AI:} Explored the power of low-code automation with n8n and integrated a cutting-edge AI service (OpenAI) to build a practical, natural language-powered conversational interface.
\end{itemize}

\subsection{Personal Contributions}
Beyond the technical aspects, this project was a significant learning experience in terms of soft skills:
\begin{itemize}
    \item \textbf{Project Management:} Followed the Scrum methodology, participating in sprint planning, execution, and review. This improved skills in time management, task prioritization, and iterative development.
    \item \textbf{Problem-Solving:} Faced and overcame numerous technical challenges, from configuring complex security rules to debugging intricate integration workflows, thereby strengthening analytical and problem-solving abilities.
    \item \textbf{Autonomy and Initiative:} Drove the project from conception to completion, making key architectural decisions and independently researching solutions to technical hurdles.
\end{itemize}

\section{Limitations and Future Prospects}
While the Dalanda solution is fully functional and meets its core objectives, there are several avenues for future improvement and expansion:

\begin{itemize}
    \item \textbf{Immediate Improvements:}
    \begin{itemize}
        \item \textbf{Multi-Currency Support:} Add the ability to create invoices in different currencies.
        \item \textbf{Customizable PDF Templates:} Allow users to choose from several PDF templates or customize them with their own branding.
        \item \textbf{Dashboard and Analytics:} Implement a dashboard with key metrics like total revenue, outstanding payments, and revenue per client.
    \end{itemize}
    \item \textbf{Future Evolutions:}
    \begin{itemize}
        \item \textbf{Payment Gateway Integration:} Integrate with payment gateways like Stripe or PayPal to allow clients to pay invoices directly online.
        \item \textbf{Recurring Invoices:} Add a feature to automatically generate and send invoices on a recurring schedule for subscription-based services.
        \item \textbf{Expansion to Other Platforms:} Adapt the conversational assistant to work with other messaging platforms like WhatsApp or Slack to reach a wider user base.
    \end{itemize}
\end{itemize}

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\begin{thebibliography}{99} 
    \bibitem{spring}
    Site officiel de Spring Boot. \url{https://spring.io/projects/spring-boot}
    
    \bibitem{angular}
    Site officiel d'Angular. \url{https://angular.io/}
    
    \bibitem{n8n}
    Site officiel de n8n. \url{https://n8n.io/}

    \bibitem{itext}
    Site officiel d'iTextPDF. \url{https://itextpdf.com/}
    
    % Add other references: books, articles, documentation pages...
\end{thebibliography}

%----------------------------------------------------------------------------------------
%	APPENDICES
%----------------------------------------------------------------------------------------

\appendix
\chapter{Key Configuration Files}
\section{Backend - pom.xml}
\begin{lstlisting}[language=XML, caption={pom.xml file of the Spring Boot project.}]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>Dalanda</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Dalanda</name>
    <description>Dalanda</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <!-- JJWT API -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <!-- JJWT runtime implementations -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itextpdf</artifactId>
            <version>5.5.13.3</version>
        </dependency>
        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <version>10.2.0.jre17</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </path>
                    </annotationProcessorPaths>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <release>${java.version}</release>

                </configuration>
            </plugin>

            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
\end{lstlisting}

\section{Backend - application.properties}
\begin{lstlisting}[language=properties, caption={application.properties file of the Spring Boot project.}]
spring.application.name=Dalanda
# ?? DATASOURCE ???????????????????????????????????????????????????????????????
spring.datasource.url=jdbc:mysql://localhost:3306/dalandadb?createDatabaseIfNotExist=true&useSSL=false&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# ?? JPA / HIBERNATE ??????????????????????????????????????????????????????????
# `update` will create missing tables/columns (but not drop anything).
# Use `create` if you want Hibernate to drop+recreate schema on each start.
spring.jpa.hibernate.ddl-auto=update
# show SQL
spring.jpa.show-sql=true
# MySQL8 dialect
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
# JWT settings
jwt.secret=k34P/y8j7RL9b/w/6syAsnY1o6KbiimA3kEj2+XItEc=
jwt.expirationMs=3600000
\end{lstlisting}

\section{Frontend - package.json}
\begin{lstlisting}[language=json, caption={package.json file of the Angular project.}]
{
  "name": "dalanda-frontend",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^19.2.8",
    "@angular/cdk": "^19.2.11",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/forms": "^19.2.0",
    "@angular/material": "^19.2.11",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/router": "^19.2.0",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.9",
    "@angular/cli": "^19.2.9",
    "@angular/compiler-cli": "^19.2.0",
    "@types/jasmine": "~5.1.0",
    "jasmine-core": "~5.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "typescript": "~5.7.2"
  }
}
\end{lstlisting}

\section{Frontend - angular.json}
\begin{lstlisting}[language=json, caption={angular.json file of the Angular project.}]
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "dalanda-frontend": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "standalone": false
        },
        "@schematics/angular:directive": {
          "standalone": false
        },
        "@schematics/angular:pipe": {
          "standalone": false
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/dalanda-frontend",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "@angular/material/prebuilt-themes/magenta-violet.css",
              "src/styles.css"
            ],
            "scripts": []
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "dalanda-frontend:build:production"
            },
            "development": {
              "buildTarget": "dalanda-frontend:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "@angular/material/prebuilt-themes/magenta-violet.css",
              "src/styles.css"
            ],
            "scripts": []
          }
        }
      }
    }
  }
}
\end{lstlisting}

\chapter{Docker Configuration}
\section{Docker - docker-compose.yml}
\begin{lstlisting}[language=yaml, caption={docker-compose.yml file for the project.}]
version: '3.8'

services:
  db:
    image: mysql:8.0
    restart: always
    environment:
      # Create your database
      MYSQL_DATABASE: dalandadb
      # Allow the root user to have an empty password
      MYSQL_ALLOW_EMPTY_PASSWORD: "yes"
    ports:
      - "3306:3306"
    volumes:
      - db_data:/var/lib/mysql

  app:
    image: karimkli/my-spring-api
    depends_on:
      - db
    environment:
      SPRING_DATASOURCE_URL:      jdbc:mysql://db:3306/dalandadb?createDatabaseIfNotExist=true&useSSL=false&serverTimezone=UTC
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: ""
    ports:
      - "8080:8080"
    restart: on-failure

volumes:
  db_data:
\end{lstlisting}

\section{Docker - Dockerfile}
\begin{lstlisting}[language=dockerfile, caption={Dockerfile for the backend application.}]
# Dockerfile
FROM eclipse-temurin:17-jre
VOLUME /tmp
COPY target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app.jar"]
\end{lstlisting}


\end{document}
